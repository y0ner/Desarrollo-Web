import * as i0 from '@angular/core';
import { Injectable, forwardRef, input, booleanAttribute, EventEmitter, inject, numberAttribute, ContentChildren, ContentChild, Output, Input, HostListener, ChangeDetectionStrategy, Component, NgModule } from '@angular/core';
import { style } from '@primeuix/styles/togglebutton';
import { BaseStyle } from 'primeng/base';
import * as i2 from '@angular/common';
import { CommonModule } from '@angular/common';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { SharedModule, PrimeTemplate } from 'primeng/api';
import { BaseEditableHolder } from 'primeng/baseeditableholder';
import * as i1 from 'primeng/ripple';
import { Ripple } from 'primeng/ripple';

const theme = /*css*/ `
    ${style}

    /* For PrimeNG (iconPos) */
    .p-togglebutton-icon-right {
        order: 1;
    }

    .p-togglebutton.ng-invalid.ng-dirty {
        border-color: dt('togglebutton.invalid.border.color');
    }
`;
const classes = {
    root: ({ instance }) => [
        'p-togglebutton p-component',
        {
            'p-togglebutton-checked': instance.checked,
            'p-invalid': instance.invalid(),
            'p-disabled': instance.$disabled(),
            'p-togglebutton-sm p-inputfield-sm': instance.size === 'small',
            'p-togglebutton-lg p-inputfield-lg': instance.size === 'large',
            'p-togglebutton-fluid': instance.fluid()
        }
    ],
    content: 'p-togglebutton-content',
    icon: 'p-togglebutton-icon',
    iconLeft: 'p-togglebutton-icon-left',
    iconRight: 'p-togglebutton-icon-right',
    label: 'p-togglebutton-label'
};
class ToggleButtonStyle extends BaseStyle {
    name = 'togglebutton';
    theme = theme;
    classes = classes;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: ToggleButtonStyle, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: ToggleButtonStyle });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: ToggleButtonStyle, decorators: [{
            type: Injectable
        }] });
/**
 *
 * ToggleButton is used to select a boolean value using a button.
 *
 * [Live Demo](https://www.primeng.org/togglebutton/)
 *
 * @module togglebuttonstyle
 *
 */
var ToggleButtonClasses;
(function (ToggleButtonClasses) {
    /**
     * Class name of the root element
     */
    ToggleButtonClasses["root"] = "p-togglebutton";
    /**
     * Class name of the icon element
     */
    ToggleButtonClasses["icon"] = "p-togglebutton-icon";
    /**
     * Class name of the left icon
     */
    ToggleButtonClasses["iconLeft"] = "p-togglebutton-icon-left";
    /**
     * Class name of the right icon
     */
    ToggleButtonClasses["iconRight"] = "p-togglebutton-icon-right";
    /**
     * Class name of the label element
     */
    ToggleButtonClasses["label"] = "p-togglebutton-label";
})(ToggleButtonClasses || (ToggleButtonClasses = {}));

const TOGGLEBUTTON_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => ToggleButton),
    multi: true
};
/**
 * ToggleButton is used to select a boolean value using a button.
 * @group Components
 */
class ToggleButton extends BaseEditableHolder {
    onKeyDown(event) {
        switch (event.code) {
            case 'Enter':
                this.toggle(event);
                event.preventDefault();
                break;
            case 'Space':
                this.toggle(event);
                event.preventDefault();
                break;
        }
    }
    toggle(event) {
        if (!this.$disabled() && !(this.allowEmpty === false && this.checked)) {
            this.checked = !this.checked;
            this.writeModelValue(this.checked);
            this.onModelChange(this.checked);
            this.onModelTouched();
            this.onChange.emit({
                originalEvent: event,
                checked: this.checked
            });
            this.cd.markForCheck();
        }
    }
    /**
     * Label for the on state.
     * @group Props
     */
    onLabel = 'Yes';
    /**
     * Label for the off state.
     * @group Props
     */
    offLabel = 'No';
    /**
     * Icon for the on state.
     * @group Props
     */
    onIcon;
    /**
     * Icon for the off state.
     * @group Props
     */
    offIcon;
    /**
     * Defines a string that labels the input for accessibility.
     * @group Props
     */
    ariaLabel;
    /**
     * Establishes relationships between the component and label(s) where its value should be one or more element IDs.
     * @group Props
     */
    ariaLabelledBy;
    /**
     * Style class of the element.
     * @deprecated since v20.0.0, use `class` instead.
     * @group Props
     */
    styleClass;
    /**
     * Identifier of the focus input to match a label defined for the component.
     * @group Props
     */
    inputId;
    /**
     * Index of the element in tabbing order.
     * @group Props
     */
    tabindex = 0;
    /**
     * Position of the icon.
     * @group Props
     */
    iconPos = 'left';
    /**
     * When present, it specifies that the component should automatically get focus on load.
     * @group Props
     */
    autofocus;
    /**
     * Defines the size of the component.
     * @group Props
     */
    size;
    /**
     * Whether selection can not be cleared.
     * @group Props
     */
    allowEmpty;
    /**
     * Spans 100% width of the container when enabled.
     * @defaultValue undefined
     * @group Props
     */
    fluid = input(undefined, ...(ngDevMode ? [{ debugName: "fluid", transform: booleanAttribute }] : [{ transform: booleanAttribute }]));
    /**
     * Callback to invoke on value change.
     * @param {ToggleButtonChangeEvent} event - Custom change event.
     * @group Emits
     */
    onChange = new EventEmitter();
    /**
     * Custom icon template.
     * @group Templates
     */
    iconTemplate;
    /**
     * Custom content template.
     * @group Templates
     */
    contentTemplate;
    templates;
    checked = false;
    _componentStyle = inject(ToggleButtonStyle);
    onBlur() {
        this.onModelTouched();
    }
    get hasOnLabel() {
        return (this.onLabel && this.onLabel.length > 0);
    }
    get hasOffLabel() {
        return (this.onLabel && this.onLabel.length > 0);
    }
    get active() {
        return this.checked === true;
    }
    _iconTemplate;
    _contentTemplate;
    ngAfterContentInit() {
        this.templates.forEach((item) => {
            switch (item.getType()) {
                case 'icon':
                    this._iconTemplate = item.template;
                    break;
                case 'content':
                    this._contentTemplate = item.template;
                    break;
                default:
                    this._contentTemplate = item.template;
                    break;
            }
        });
    }
    /**
     * @override
     *
     * @see {@link BaseEditableHolder.writeControlValue}
     * Writes the value to the control.
     */
    writeControlValue(value, setModelValue) {
        this.checked = value;
        setModelValue(value);
        this.cd.markForCheck();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: ToggleButton, deps: null, target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.2.1", type: ToggleButton, isStandalone: true, selector: "p-toggleButton, p-togglebutton, p-toggle-button", inputs: { onLabel: { classPropertyName: "onLabel", publicName: "onLabel", isSignal: false, isRequired: false, transformFunction: null }, offLabel: { classPropertyName: "offLabel", publicName: "offLabel", isSignal: false, isRequired: false, transformFunction: null }, onIcon: { classPropertyName: "onIcon", publicName: "onIcon", isSignal: false, isRequired: false, transformFunction: null }, offIcon: { classPropertyName: "offIcon", publicName: "offIcon", isSignal: false, isRequired: false, transformFunction: null }, ariaLabel: { classPropertyName: "ariaLabel", publicName: "ariaLabel", isSignal: false, isRequired: false, transformFunction: null }, ariaLabelledBy: { classPropertyName: "ariaLabelledBy", publicName: "ariaLabelledBy", isSignal: false, isRequired: false, transformFunction: null }, styleClass: { classPropertyName: "styleClass", publicName: "styleClass", isSignal: false, isRequired: false, transformFunction: null }, inputId: { classPropertyName: "inputId", publicName: "inputId", isSignal: false, isRequired: false, transformFunction: null }, tabindex: { classPropertyName: "tabindex", publicName: "tabindex", isSignal: false, isRequired: false, transformFunction: numberAttribute }, iconPos: { classPropertyName: "iconPos", publicName: "iconPos", isSignal: false, isRequired: false, transformFunction: null }, autofocus: { classPropertyName: "autofocus", publicName: "autofocus", isSignal: false, isRequired: false, transformFunction: booleanAttribute }, size: { classPropertyName: "size", publicName: "size", isSignal: false, isRequired: false, transformFunction: null }, allowEmpty: { classPropertyName: "allowEmpty", publicName: "allowEmpty", isSignal: false, isRequired: false, transformFunction: null }, fluid: { classPropertyName: "fluid", publicName: "fluid", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { onChange: "onChange" }, host: { listeners: { "keydown": "onKeyDown($event)", "click": "toggle($event)" }, properties: { "class": "cn(cx('root'), styleClass)", "attr.aria-labelledby": "ariaLabelledBy", "attr.aria-pressed": "checked", "attr.role": "\"button\"", "attr.tabindex": "!$disabled() ? 0 : -1" } }, providers: [TOGGLEBUTTON_VALUE_ACCESSOR, ToggleButtonStyle], queries: [{ propertyName: "iconTemplate", first: true, predicate: ["icon"] }, { propertyName: "contentTemplate", first: true, predicate: ["content"] }, { propertyName: "templates", predicate: PrimeTemplate }], usesInheritance: true, hostDirectives: [{ directive: i1.Ripple }], ngImport: i0, template: `<span [class]="cx('content')">
        <ng-container *ngTemplateOutlet="contentTemplate || _contentTemplate; context: { $implicit: checked }"></ng-container>
        @if (!contentTemplate) {
            @if (!iconTemplate) {
                @if (onIcon || offIcon) {
                    <span [class]="cn(cx('icon'), checked ? this.onIcon : this.offIcon, iconPos === 'left' ? cx('iconLeft') : cx('iconRight'))" [attr.data-pc-section]="'icon'"></span>
                }
            } @else {
                <ng-container *ngTemplateOutlet="iconTemplate || _iconTemplate; context: { $implicit: checked }"></ng-container>
            }
            <span [class]="cx('label')" [attr.data-pc-section]="'label'">{{ checked ? (hasOnLabel ? onLabel : ' ') : hasOffLabel ? offLabel : ' ' }}</span>
        }
    </span>`, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "ngmodule", type: SharedModule }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: ToggleButton, decorators: [{
            type: Component,
            args: [{
                    selector: 'p-toggleButton, p-togglebutton, p-toggle-button',
                    standalone: true,
                    imports: [CommonModule, SharedModule],
                    hostDirectives: [{ directive: Ripple }],
                    host: {
                        '[class]': "cn(cx('root'), styleClass)",
                        '[attr.aria-labelledby]': 'ariaLabelledBy',
                        '[attr.aria-pressed]': 'checked',
                        '[attr.role]': '"button"',
                        '[attr.tabindex]': '!$disabled() ? 0 : -1'
                    },
                    template: `<span [class]="cx('content')">
        <ng-container *ngTemplateOutlet="contentTemplate || _contentTemplate; context: { $implicit: checked }"></ng-container>
        @if (!contentTemplate) {
            @if (!iconTemplate) {
                @if (onIcon || offIcon) {
                    <span [class]="cn(cx('icon'), checked ? this.onIcon : this.offIcon, iconPos === 'left' ? cx('iconLeft') : cx('iconRight'))" [attr.data-pc-section]="'icon'"></span>
                }
            } @else {
                <ng-container *ngTemplateOutlet="iconTemplate || _iconTemplate; context: { $implicit: checked }"></ng-container>
            }
            <span [class]="cx('label')" [attr.data-pc-section]="'label'">{{ checked ? (hasOnLabel ? onLabel : ' ') : hasOffLabel ? offLabel : ' ' }}</span>
        }
    </span>`,
                    providers: [TOGGLEBUTTON_VALUE_ACCESSOR, ToggleButtonStyle],
                    changeDetection: ChangeDetectionStrategy.OnPush
                }]
        }], propDecorators: { onKeyDown: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }], toggle: [{
                type: HostListener,
                args: ['click', ['$event']]
            }], onLabel: [{
                type: Input
            }], offLabel: [{
                type: Input
            }], onIcon: [{
                type: Input
            }], offIcon: [{
                type: Input
            }], ariaLabel: [{
                type: Input
            }], ariaLabelledBy: [{
                type: Input
            }], styleClass: [{
                type: Input
            }], inputId: [{
                type: Input
            }], tabindex: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], iconPos: [{
                type: Input
            }], autofocus: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], size: [{
                type: Input
            }], allowEmpty: [{
                type: Input
            }], onChange: [{
                type: Output
            }], iconTemplate: [{
                type: ContentChild,
                args: ['icon', { descendants: false }]
            }], contentTemplate: [{
                type: ContentChild,
                args: ['content', { descendants: false }]
            }], templates: [{
                type: ContentChildren,
                args: [PrimeTemplate]
            }] } });
class ToggleButtonModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: ToggleButtonModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.2.1", ngImport: i0, type: ToggleButtonModule, imports: [ToggleButton, SharedModule], exports: [ToggleButton, SharedModule] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: ToggleButtonModule, imports: [ToggleButton, SharedModule, SharedModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.1", ngImport: i0, type: ToggleButtonModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [ToggleButton, SharedModule],
                    exports: [ToggleButton, SharedModule]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { TOGGLEBUTTON_VALUE_ACCESSOR, ToggleButton, ToggleButtonClasses, ToggleButtonModule, ToggleButtonStyle };
//# sourceMappingURL=primeng-togglebutton.mjs.map
